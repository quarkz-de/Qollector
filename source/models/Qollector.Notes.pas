unit Qollector.Notes;

interface

uses
  System.SysUtils, System.Generics.Collections, System.IOUtils,
  Spring, Spring.Collections, Spring.Persistence.Mapping.Attributes;

type
  TNotebookItem = class;
  TLinkItem = class;

  [Entity]
  [Table('NOTES')]
  TNoteItem = class
  private
    [Column('ID', [cpRequired, cpPrimaryKey])][AutoGenerated]
    FId: Integer;
    FNotebookId: Integer;
    FName: String;
    FText: String;
    FPosition: Integer;
    FNotebook: TNotebookItem;
    [OneToMany(False, [ckCascadeAll])]
    FLinks: Lazy<IList<TLinkItem>>;
  public
    constructor Create; virtual;
    destructor Destroy; override;

    property Id: Integer read FId;

    [Column('NOTEBOOK')]
    [ForeignJoinColumn('NOTEBOOK', 'NOTEBOOKS', 'ID', [fsOnDeleteCascade, fsOnUpdateCascade])]
    property NotebookId: Integer read FNotebookId write FNotebookId;

    [Column('NAME')]
    property Name: String read FName write FName;

    [Column('TEXT')]
    property Text: String read FText write FText;

    [Column('POSITION')]
    property Position: Integer read FPosition write FPosition;

    [ManyToOne(False, [ckCascadeAll], 'NotebookId')]
    property Notebook: TNotebookItem read FNotebook write FNotebook;

    property Links: Lazy<IList<TLinkItem>> read FLinks write FLinks;

    function ToString: String; override;
  end;

  TLinkItemType = (litUnknown, litBookmark, litFavoriteFile);

  [Entity]
  [Table('LINKS')]
  TLinkItem = class
  private
    [Column('ID', [cpRequired, cpPrimaryKey])][AutoGenerated]
    FId: Integer;
    FNoteId: Integer;
    FName: String;
    FFilename: String;
    FNote: TNoteItem;
    function GetItemType: TLinkItemType;
  public
    destructor Destroy; override;

    property Id: Integer read FId;

    [Column('NOTE')]
    [ForeignJoinColumn('NOTE', 'NOTES', 'ID', [fsOnDeleteCascade, fsOnUpdateCascade])]
    property NoteId: Integer read FNoteId write FNoteId;

    [Column('NAME')]
    property Name: String read FName write FName;

    [Column('FILENAME')]
    property Filename: String read FFilename write FFilename;

    [ManyToOne(False, [ckCascadeAll], 'NoteId')]
    property Note: TNoteItem read FNote write FNote;

    property ItemType: TLinkItemType read GetItemType;

    function ToString: String; override;
  end;

  [Entity]
  [Table('NOTEBOOKS')]
  TNotebookItem = class
  private
    [Column('ID', [cpRequired, cpPrimaryKey])][AutoGenerated]
    FId: Integer;
    FName: String;
    FPosition: Integer;
    [OneToMany(False, [ckCascadeAll])]
    FNotes: Lazy<IList<TNoteItem>>;
  public
    constructor Create;

    property Id: Integer read FId write FId;

    [Column('NAME')]
    property Name: String read FName write FName;

    [Column('POSITION')]
    property Position: Integer read FPosition write FPosition;

    property Notes: Lazy<IList<TNoteItem>> read FNotes write FNotes;

    function ToString: String; override;
  end;

implementation

uses
  Qollector.Execute;

{ TNoteItem }

constructor TNoteItem.Create;
begin
  inherited;
  FLinks := TCollections.CreateObjectList<TLinkItem>;
end;

destructor TNoteItem.Destroy;
begin
  if Assigned(FNotebook) then
    begin
{$IFDEF AUTOREFCOUNT}
      FNotebook.DisposeOf;
{$ENDIF}
      FNotebook.Free;
    end;
  inherited;
end;

function TNoteItem.ToString: String;
begin
  Result := Name;
end;

{ TNotebookItem }

constructor TNotebookItem.Create;
begin
  inherited;
  FNotes := TCollections.CreateObjectList<TNoteItem>;
end;

function TNotebookItem.ToString: String;
begin
  Result := Name;
end;

{ TLinkItem }

destructor TLinkItem.Destroy;
begin
  if Assigned(FNote) then
    begin
{$IFDEF AUTOREFCOUNT}
      FNote.DisposeOf;
{$ENDIF}
      FNote.Free;
    end;
  inherited;
end;

function TLinkItem.GetItemType: TLinkItemType;
begin
  if TShellExecute.IsUrl(Filename) then
    Result := litBookmark
  else if TFile.Exists(Filename) then
    Result := litFavoriteFile
  else
    Result := litUnknown;
end;

function TLinkItem.ToString: String;
begin
  Result := Name;
end;

end.
